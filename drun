#!/usr/bin/env ruby

# drun gnome run dialog
# Copyright (C) 2008 David Maciver
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

require 'gtk2'

Windows = (ENV['OS'] =~ /Windows/)

if Windows
	PATH = ENV['PATH'].split(/;/).map { |x| x.gsub('\\', '/') }
	HOME = ENV['USERPROFILE'].gsub('\\', '/')
else
	PATH = ENV['PATH'].split(/:/)
	HOME = ENV['HOME']
end

HistFile = "#{HOME}/.drun-history"
ConfigFile = "#{HOME}/.drunrc"

useFifo = false

# If a directory is passed, then that is what the CWD is set to.
# If filenames are passed, then the CWD is the location of the first file and the files are added as arguments
$execpath = nil
$execargs = nil
if ARGV.length > 0
	if ARGV.length == 1 and ARGV[0] == '--fifo'
		useFifo = true
		$execpath = HOME
	elsif File.directory? ARGV[0]
		$execpath = ARGV[0]
	else
		$execargs = ARGV.map{ |x| "\"#{x}\"" }.join(' ')
		$execpath = ARGV[0][0..ARGV[0].rindex('/')] if ARGV[0][0..0] == '/'
	end
end

class Configuration
	def initialize(configfile)
		@httpHandler = "firefox"
		@sshHandler = "xterm -e ssh"
		@fileHandler = "gnome-open"
		@directoryHandler = "nautilus"
		@terminalHandler = "Terminal -e"

		return if not File.exists? configfile

		File.readlines(configfile).each { |line|
			if line =~ /^\s*http-handler\s*=(.*)/i
				@httpHandler = $1.strip
			elsif line =~ /^\s*ssh-handler\s*=(.*)/i
				@sshHandler = $1.strip
			elsif line =~ /^\s*file-handler\s*=(.*)/i
				@fileHandler = $1.strip
			elsif line =~ /^\s*directory-handler\s*=(.*)/i
				@directoryHandler = $1.strip
			elsif line =~ /^\s*terminal-handler\s*=(.*)/i
				@terminalHandler = $1.strip
			end
		}
	end

	attr_reader :httpHandler, :sshHandler, :fileHandler, :directoryHandler, :terminalHandler
end

# Keeps a history of recently run commands along with how many times they were run, reading/writing them to a file
class History
	def initialize(histfile)
		@histfile = histfile

		@entries = []
		@recent = []
	
		return if not File.exists? HistFile

		# Load history from HistFile which is formatted as a list of recent commands
		# then a blank line, then a list of "count command" in descending order by count
		recent = true
		File.readlines(HistFile).each { |line|
			if line =~ /^$/
				recent = false
			else
				if recent
					@recent += [line.strip]
				else
					line =~ /(\d*) (.*)/
					@entries += [[$1.to_i, $2]]
				end
			end
		}

		@entries.sort!.reverse!
	end

	def delete(input)
		# Deletes the entries matching input
		@entries.delete_if { |entry| entry[1] == input }
		@recent.delete_if { |recent| recent == input }

		# Update history file
		writeFile
	end

	def incCount(input)
		# Increments the count of the entry matching input or adds a new entry
		i = nil
		@entries.each_index { |x| i = x if @entries[x][1] == input }
		if i
			# Input exists, increment count
			@entries[i][0] += 1
		else
			# Add new entry
			@entries += [[1, input]]
		end

		# Only save 500 most significant entries
		@entries = @entries[0...500] if @entries.length > 500

		# Update recent entries
		@recent = [input] + @recent
		@recent.uniq!
		@recent = @recent[0...50] if @recent.length > 50

		# Update history file
		writeFile
	end

	def entries
		@entries
	end

	def recent
		@recent
	end
private
	def writeFile
		# Writes entries to HistFile
		File.open(@histfile, 'w') { |file|
			@recent.each { |x|
				file.puts x
			}
			file.puts
			@entries.each { |x|
				file.puts "#{x[0]} #{x[1]}"
			}
		}
	end
end

# Finds completions based on the history and the file system
class Completion
	def initialize(history)
		@history = history
	end

	def getRecent
		@history.recent
	end

	def getCompletion(input)
		c = getCompletionCorrections(input, 0)
		c = getCompletionCorrections(input, 2) if c == []
		c = getCompletionCorrections(input, 4) if c == []

		return c
	end

	def execInput(input, inTerminal=false)
		config = Configuration.new(ConfigFile)

		input.gsub!(/\//, '\\\\') if Windows

		input = expandHome(input)

		# Find program corresponding to a url
		if input =~ /^(\w*):\/\/(.*)/
			prog = config.httpHandler if $1 == 'http'
			prog = config.fileHandler if $1 == 'file'
			if $1 == 'ssh'
				input.gsub!(/ssh:\/\//, '')
				prog = config.sshHandler
			end
		end

		if not prog
			prefix, _ = getPrefixSuffix(input, false)

			prefix = unescape(prefix.strip)

			return if prefix == ''

			if not which(prefix)
				if File.directory? prefix
					prog = config.directoryHandler
				elsif not executable? prefix and File.file? prefix
					prog = config.fileHandler
				elsif not executable? prefix
					return
				end
			end
		end

		input = "#{prog} #{input}"
		input = config.terminalHandler + ' "' + input.gsub(/"/, '\\"') + '"' if inTerminal
		Dir.chdir $execpath if $execpath
		input += " #{$execargs}" if $execargs

		Thread.new { system(input) }

		return true
	end
private
	def unescape(input)
		# Remove the first backslash of a backslash followed by an escaped character

		s = ''
		while input and input.length > 0
			if input =~ /^\\/
				s += input[1..1]
				input = input[2..-1]
			else
				s += input[0..0]
				input = input[1..-1]
			end
		end
		s
	end

	def escape(input)
		# Add a backslash before backslashes, quotes, and shell metacharacters

		input.gsub(/([ \\'"|&;()<>])/, "\\\\\\1")
	end

	def getPrefixSuffix(input, greedyPrefix)
		# Return the parts of a string before and after the first or last unescaped space

		# TODO: Handle escaped backslashes

		if greedyPrefix and input =~ /^(.*[^ \\]) ([^ \\].*)/
			# Prefix is up to last space
			return $1, $2
		elsif not greedyPrefix and input =~ /^([^ \\]+) ([^ \\].*)/
			# Prefix is up to first space
			return $1, $2
		else
			return input, nil
		end
	end

	def which(file)
		# Return the full path to an executable file by searching the path variable

		suffixes = ['']
		suffixes = ['', '.exe', '.bat', '.lnk'] if Windows

		PATH.each { |dir|
			suffixes.each { |suf|
				f = "#{dir}/#{file}#{suf}"
				return f if executable? f and not File.directory? f
			}
		}
		return nil
	end

	def getCompletionCorrections(input, corrections)
		# Complete the text after the last space

		prefix, suffix = getPrefixSuffix(input, true)

		if suffix
			c = getCompletionHist(unescape(input), corrections)
			c += getCompletionPartial(unescape(suffix), corrections).map { |x| "#{prefix} #{x}" }
			c.uniq
		else
			getCompletionPartial(unescape(input), corrections)
		end
	end

	def expandHome(input)
		match = input.match(/^~\//)
		if match
			return input.sub(match[0], HOME + '/')
		end

		if not Windows
			match = input.match(/^~[^\/]*/)
			if match
				begin
					return input.sub(match[0], File.expand_path(match[0]))
				rescue
				end
			end
		end

		return input
	end

	def getCompletionPartial(input, corrections)
		ret = []

		return ret if input.length == 0

		input = expandHome(input)

		if input[0].chr == '/' or input =~ /^file:\/\// or (Windows and input.length > 1 and input[1].chr == ':')
			# Complete absolute path
			ret += getCompletionDir(input, corrections)
		else
			# Complete executable from history and path
			ret += getCompletionHist(input, corrections)
			ret += getCompletionPath(input, corrections)
		end

		ret.uniq
	end

	def getCompletionDir(input, corrections)
		# Completes an absolute path
		input = input.sub(/^file:\/\//, '')

		# If any of the parent directories don't exist, recursively expand these directories first
		s = input.split(/\//)[0..-1]
		if not File.directory? s.join('/')
			2.upto(s.length - 1) { |x|
				if not File.directory? s[0...x].join('/')
					return getCompletionDir(s[0...x].join('/'), 0).map { |y|
						y + s[x..-1].join('/')
					}.map { |y|
						getCompletionDir(unescape(y), corrections)
					}.flatten
				end
			}
		end

		if input =~ /\/$/
			glob = "#{input}*"
		else
			dirname = File.dirname(input)
			# Find hidden files if the input filename starts with a dot
			if File.basename(input) =~ /^\./
				glob = "#{dirname}/.*"
			else
				glob = "#{dirname}/*"
			end
			glob.gsub!(/\/\//, '/')
		end

		beginsWith(Dir.glob(glob), input, corrections).map { |x|
			x = File.directory?(x) ? "#{x}/" : x
			x = escape(x)
		}
	end

	def getCompletionHist(input, corrections)
		# Completes based on history
		beginsWith(@history.entries.map { |x| x[1] }, input, corrections)
	end

	def getCompletionPath(input, corrections)
		# Completes an executable name based on contents of PATH
		# Ignores hidden files in the path

		# A filename beginning with equals is substituted for a full path
		fullpath = false
		if input =~ /^=/
			input = input.sub(/^=/, '')
			fullpath = true
		end

		ret = []
		PATH.each { |dir|
			beginsWith(filesInDir(dir), input, corrections).each { |file| ret << [dir, file] }
		}

		if Windows
			ret.reject! { |x| not executable? x[1] }
			ret.map! { |dir, file| [dir, file.gsub(/\.(exe|lnk|bat)$/i, '')] }
		end
		
		ret.sort_by { |x| x[1] }.map { |x| fullpath ? (x[0] + '/' + x[1]) : x[1] }
	end

	def filesInDir(dir)
		# Gets a list of all files in dir
		Dir.glob("#{dir}/*").map { |x| escape(File.basename(x)) }
	end

	def beginsWith(list, prefix, corrections)
		if corrections == 0
			# Select items from list that begin with prefix or prefix with some characters converted to uppercase
			prefix = Regexp.escape(prefix)
			prefix = prefix.split(//).map { |c| (c == c.downcase and c =~ /[a-zA-Z]/) ? "[#{c + c.upcase}]" : c }.join
			return list.select { |x| x =~ /^#{prefix}/ }
		else
			return list.select { |x| x.split(//)[0] == prefix.split(//)[0] and editDistance(prefix, x[0...prefix.length]) <= corrections }
		end
	end

	def executable?(file)
		if Windows
			file =~ /\.(exe|lnk|bat)$/i
		else
			File.executable? file
		end
	end

	def editDistance(a, b)
		# Return the minimum number of insertions, deletions or subsitutions needed to transform a into b
		# Allow any characters in a to be converted to uppercase

		d = Array.new(a.length+1).map { Array.new(b.length+1) }
		0.upto(a.length) { |x| d[x][0] = x }
		0.upto(b.length) { |x| d[0][x] = x }

		asplit = [nil] + a.split(//)
		bsplit = [nil] + b.split(//)

		1.upto(a.length) { |x|
			1.upto(b.length) { |y|
				d[x][y] = [
					d[x][y-1] + 1,
					d[x-1][y] + 1,
					d[x-1][y-1] + ((asplit[x] == bsplit[y] or asplit[x].upcase == bsplit[y]) ? 0 : 2)
				].min
			}
		}

		d.last.last
	end
end

# A scrollable completion list window that calls various blocks on different events
class CompletionWindow < Gtk::Window
	def initialize(parent)
		super(Gtk::Window::POPUP)

		@parent = parent
		
		@liststore = Gtk::ListStore.new(String)
		@treeview = Gtk::TreeView.new(@liststore)
		@treeview.headers_visible = false
		@treeview.insert_column(-1, "text", Gtk::CellRendererText.new, {:text => 0})
		@treeview.signal_connect('cursor_changed') { changeCompletion }

		@treeview.signal_connect('row_activated') { dismissCompletion; @activatedblock.call(false) }

		@scroll = Gtk::ScrolledWindow.new
		@scroll.add(@treeview)
		@scroll.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC)
		set_transient_for(parent)
		set_default_size(350, 200)
		set_accept_focus(false)

		frame = Gtk::Frame.new
		frame.add(@scroll)
		add(frame)
	end

	# Block to call to get a list of completions
	def setCompletionBlock(&completionblock)
		@completionblock = completionblock
	end

	# Block to call when a completion has been selected
	def setFinishedCompletionBlock(&finishedcompletionblock)
		@finishedcompletionblock = finishedcompletionblock
	end

	# Block to call when a completion entry has been deleted
	def setDeletionBlock(&deletionblock)
		@deletionblock = deletionblock
	end

	# Block to call to get the position to display a completion window
	def setGetPositionBlock(&getpositionblock)
		@getpositionblock = getpositionblock
	end

	# Block to call when a command is activated to run
	def setActivatedBlock(&activatedblock)
		@activatedblock = activatedblock
	end

	# Call to handle a gtk key press event
	def keyPressEvent(event)
		down = event.keyval == Gdk::Keyval::GDK_Down
		down ||= event.keyval == Gdk::Keyval::GDK_Tab
		up = event.keyval == Gdk::Keyval::GDK_Up
		del = event.keyval == Gdk::Keyval::GDK_Delete
		pagedown = event.keyval == Gdk::Keyval::GDK_Page_Down
		pageup = event.keyval == Gdk::Keyval::GDK_Page_Up

		ret = event.keyval == Gdk::Keyval::GDK_Return
		control = ((event.state & Gdk::Window::CONTROL_MASK) == Gdk::Window::CONTROL_MASK)
		shift = ((event.state & Gdk::Window::SHIFT_MASK) == Gdk::Window::SHIFT_MASK)

		up ||= (shift and event.keyval == Gdk::Keyval::GDK_ISO_Left_Tab)

		if ret
			dismissCompletion
			@activatedblock.call(control)
			true
		elsif up or down or pageup or pagedown
			# Up, down and tab moves through the completion list.
			# If it isn't being displayed, then a new completion list is generated.
			if not visible?
				return false if not @completionblock
				comp = @completionblock.call

				if comp.length == 1
					# Unique completion updates the text entry without a menu
					@finishedcompletionblock.call(comp.first)
				elsif comp.length > 1
					x,y = @getpositionblock.call
					# More than one completion creates a menu
					move(x, y)
					show_all
					# Add completion list for menu and select the first item
					@liststore.clear
					comp.each { |x|
						row = @liststore.append
						row.set_value(0, x)
					}
					@treeview.selection.select_path(Gtk::TreePath.new('0'))

					changeCompletion
				end
			else
				selected = @treeview.selection.selected
				if selected
					# Move selection up or down
					path = selected.path
					if up or pageup
						path.prev!
					elsif down or pagedown
						return if not selected.next!
						path.next!
					end
				else
					# If there isn't a selection, select the first row
					path = @liststore.iter_first.path
				end
				@treeview.selection.select_path(path)

				changeCompletion

				# Scroll window to keep selection in the middle
				@treeview.scroll_to_cell(path, nil, true, 0.5, 0.5)
			end
			true
		elsif del and visible? and @deletionblock
			selected = @treeview.selection.selected
			if selected
				# Remove the selected completion entry keeping the selection at the same location
				# There might not be any selection after running this
				path = selected.path
				text = @treeview.model.get_value(@liststore.get_iter(path), 0)
				@liststore.remove(@treeview.selection.selected)
				@treeview.selection.select_path(path)

				dismissCompletion if not @liststore.iter_first

				@deletionblock.call(text)
			end
			true
		elsif (event.keyval == Gdk::Keyval::GDK_Shift_L) or (event.keyval == Gdk::Keyval::GDK_Shift_R)
		elsif visible?
			# Any unhandled keypress dismisses the completion
			dismissCompletion
			# Don't pass escape event to parent
			return (event.keyval == Gdk::Keyval::GDK_Escape)
		end
	end
private
	def changeCompletion
		# Set the text entry to the selected completion
		path = @treeview.selection.selected.path
		text = @treeview.model.get_value(@liststore.get_iter(path), 0)

		@finishedcompletionblock.call(text) if @finishedcompletionblock
	end

	def dismissCompletion
		hide
		@parent.present
	end
end

# An entry that displays a completion list
class CompletionEntry < Gtk::Entry
	def initialize(parent)
		super()

		ignoreslashes = true

		@completionwindow = CompletionWindow.new(parent)

		@completionwindow.setFinishedCompletionBlock() { |completion|
			@completedtext = completion
			self.text = completion
			self.position = self.text.length
		}

		@completionwindow.setGetPositionBlock() {
			# Display window underneath the text entry
			rect = self.window.frame_extents
			x = rect.x
			y = rect.y + rect.height
			if not Windows
				x += 6
				y -= 8
			end
			[x,y]
		}

		self.signal_connect('key_press_event') { |widget, event|
			slash = (event.keyval == Gdk::Keyval::GDK_slash)
			escape = (event.keyval == Gdk::Keyval::GDK_Escape)
		
			handledevent = @completionwindow.keyPressEvent(event)

			if ignoreslashes
				if slash and self.text == @completedtext and @completedtext[-1].chr == '/'
					@completedtext = nil
					handledevent = true
				end
			end

			Gtk.main_quit if not handledevent and escape

			@completedtext = nil if not handledevent

			handledevent
		}
	end

	def setCompletionBlock(&block)
		@completionwindow.setCompletionBlock &block
	end

	def setDeletionBlock(&block)
		@completionwindow.setDeletionBlock &block
	end

	def setActivatedBlock(&block)
		@completionwindow.setActivatedBlock &block
	end
end

# Main window displaying a completion entry which uses the completion class
class Window < Gtk::Window
	def initialize
		super

		@history = History.new(HistFile)
		@completion = Completion.new(@history)

		@completedtext = nil

		set_type_hint(Gdk::Window::TYPE_HINT_DIALOG)
		set_window_position(Gtk::Window::POS_CENTER_ALWAYS)

		set_border_width(4)
		signal_connect('destroy') { Gtk.main_quit }
		set_default_size(500, 50)
		set_title('Run')

		vbox = Gtk::VBox.new(false, 1)

		runProgramLabel = Gtk::Label.new('  Run Program:')
		runProgramLabel.set_alignment(0, 0)
		@notFoundLabel = Gtk::Label.new('<span color="red">Command not found</span>  ')
		@notFoundLabel.set_alignment(1, 0)

		@notFoundLabel.use_markup = true

		hbox = Gtk::HBox.new(false, 1)

		hbox.pack_start(runProgramLabel, true, true)
		hbox.pack_start(@notFoundLabel, true, true)
		vbox.pack_start(hbox, false, false)

		@textentry = CompletionEntry.new(self)
		vbox.pack_start(@textentry, true, true)

		add(vbox)

		@textentry.setActivatedBlock { |inTerminal|
			if @completion.execInput(@textentry.text, inTerminal)
				@history.incCount(@textentry.text)
				Gtk.main_quit
			else
				@notFoundLabel.show
				Thread.new {
					sleep 1
					@notFoundLabel.hide
				}
			end
		}

		@textentry.setCompletionBlock() {
			if @textentry.text.length == 0
				@completion.getRecent
			else
				@completion.getCompletion(@textentry.text)
			end
		}

		@textentry.setDeletionBlock() { |text| @history.delete(text) }
	end

	def show_all
		super
		@notFoundLabel.hide
	end
end

if useFifo
	# Show run dialog when a fifo is written to and hide when fished
	fifo = open('fifo', 'r+')
	loop {
		window = Window.new
		fifo.read(1)
		window.show_all
		Gtk.main
		window.hide_all
		Gtk.main_iteration while Gtk.events_pending?
	}
else
	# Show run dialog once
	Window.new.show_all
	Gtk.main
end
